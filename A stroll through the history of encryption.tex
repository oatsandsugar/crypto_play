\documentclass{AIAA}

\begin{document}

\title{A stroll through the history of encryption}

\author{Johanan Ottensooser\footnote{Tech LLM Candidate '17} and Matthew Stichinski\footnote{Tech LLM Candidate '17}}
\affiliation{Cornell Tech, 111 8th Avenue, New York, NY 10011}

\begin{abstract}
This paper will discuss several ciphers in their historical context. Where it is within the author's skill level, the cipher will be reduced to python code; where it isn't, the cipher will be described mathematically; where even that escapes us, it will be described narratively. We intend to describe the strength and weaknesses of each cipher, what led to their development and obsolescence, and any notable stories of their use. This paper will discuss basic monoalphabetic substitution ciphers (the Atbash, Caesar and Vige\`nere ciphers as well as one time pads), basic transposition ciphers (the picket fence cipher), more complex algorithmic ciphers (the enigma cipher) and public / private key encryption (the RSA cipher). Whilst this is not a complete list of cryptographic developments, it allows us to highlight several important developments in cryptography.
\end{abstract}

\maketitle

\section{Introduction}
This paper intends to highlight several important developments in cryptography, culminating in a description of cryptographic rigor. In order to achieve this goal, this paper will encode certain ciphers in a uniform manner. This will allow the comparison of different ciphers by certain fields in their description, and an erstwhile description of their strengths and weaknesses. 

Where we have been able to, we reduce each cipher to python code\footnote{Excuse any clumsiness in the coding, neither of the authors have any formal computer science training. For the sake of brevity, only snippets of the code are extracted, for the entire program, please see $https://github.com/oatsandsugar/crypto_play$}.

\section{Defining cryptography}
There are two central mechanisms for hiding messages: \textit{steganography} and \textit{cryptography}. 

Steganography is about literally concealing messages. It has been used since classical times (for example, messages written on the wood of a wax tablet holding a false message; tattooes on the head of a slave whose hair has been allowed to grow back) and is used to this day (for example, messages encoded into insignificant digits of .jpeg files, or almost invisible yellow ink dots automatically printed that allow a knowing observer to identify the printer was used). The defining characteristic of this being that this is about obscuring an image---once the image is found, it is plain to read.

Cryptography developed later---earliest records being ancient Egyptian, Greek and Hebrew usages (from which our first two analysed ciphers, the Atbash cipher and the Caesar cypher, purportedly originate), and continue to be developed and used to the present day. 

This paper will focus on the second: \textit{cryptography}.

\subsection{Elements of a cipher}
To understand a cryptographic cipher, it is essential to understand its elements. This will allow for the easiest comparison between ciphers. An encryption system comprises:

\begin{figure}[h!]
\begin{tabular}{ | c | c | l |}
  \hline			
  $m$ & $m \in M$ & message $m$, within a message space $M$ \\
  \hline
  $gen()$  & $k \longleftarrow $Gen $s.t. k \in K$ & key generating function: generates a key $k$ within a keyspace $K$ \\
  \hline
  $k$ & $k \in K$ & key generated by $gen$ \\
  \hline
  $enc()$ & $c \longleftarrow enc_{k}(m)$ for $k \in K, m \in M$ & encryption function: generates cipher-text $c$ with inputs $k$ and $m$ \\
  \hline
  $c$ & $gen_{k}(m) = c$ & cipher-text \\
  \hline
  $dec()$ & $\forall m \in M, k \in K \longrightarrow dec_{k}(enc_{k}(m))=m$ & decryption function, returns $m$ with inputs $k$ and $c$\\
  \hline
\end{tabular}
\caption{The elements of a cipher}
\end{figure}

\subsection{What makes a good cipher}

A strong cipher is one that fulfills the requirements of its creation, be it to prove authorship of a message or to prevent the message being comprehended by an unintended viewer. A cipher that is not compromised is a good cipher, and if it can do so economically and with the least possible friction to the users, it is even more so. For the sake of shorthand, we will consider \textit{Kerchoff's principle}: that despite the message continues to be strongly encrypted when $enc()$ and $dec()$ are known, and only $k$ remains hidden. This paper will analyse the relevant ciphers against this standard.

\section{The Atbash cipher}
The Atbash cipher is purported to have been used in the old testament, as well as by ancient Israelites. It is a monoalphabetic substitution cipher where the substitution alphabet is the reverse of the plaintext alphabet:

\begin{figure}[h!]
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z \\ \hline
Z & Y & Z & W & V & U & T & R & R & Q & P & O & N & M & L & K & J & I & H & G & F & E & D & C & B & A \\
\hline
\end{tabular}
\caption{The Atbash cipher}
\end{figure}

The cipher is named for its application in the Hebrew alphabet, where the initial letter ``aleph'' is replaced by ``tav'' and ``bet'' is replaced by ``shin'': giving ``Atbash''. 

\subsection{The Atbash cipher in Python}

\subsubsection{Variables}
\begin{verbatim}
m = "" # this can be any string of ASCII characters, of any length
k = # unused in this cipher
m_ord = [] # this is m transformed into a list of integers
c_ord = []
c = ""
\end{verbatim}
Note, this the variables are identical in most ciphers discussed, and will only be discussed for subsequent ciphers if interesting, or if such discussion forms part of the criticism of that cipher.

\subsubsection{The encryption function}
\begin{verbatim}
def enc(z):
    for x in z:
        c_ord.append(27 - x + 64)
enc(m_ord)
\end{verbatim}

\subsubsection{The decryption function}
\begin{verbatim}
def dec(z):
  for x in z:
    m_ord.append(27 - x + 64)
dec(c_ord)
\end{verbatim}

\subsection{Criticism of the Atbash cipher}
The Atbash cipher is an extremely simple cipher that, without question, fails if \textit{Kerchoff's Principle} is considered. Since there is a keyspace of 1, if the encryption and decryption algorithms are known, then it is trivial to decode the ciphertext. 

\section{The Caesar cipher}
The Caesar cipher is purpoerted to have been used extensively in Roman times. Similar to the Atbash cipher, the Caesar cipher is a monoalphabetic substitution cipher. The Caesar cipher shifts each letter of the alphabet by a given number of places:

\begin{figure}[h!]
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s & t & u & v & w & x & y & z \\ \hline
W & X & Y & Z & A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q & R & S & T & U & V \\
\hline
\end{tabular}
\caption{The Caesar cipher for $k=4$}
\end{figure}
The Caesar cipher was named after its use (as purported by Suetonius in "Life of Julius Caesar") by Julius Caesar: \textit{``If he had anything confidential to say, he wrote it in cipher, that is, by so changing the order of the letters of the alphabet, that not a word could be made out. If anyone wishes to decipher these, and get at their meaning, he must substitute the fourth letter of the alphabet, namely D, for A, and so with the others.''} 

\subsection{The Caesar cipher in Python}

\subsubsection{Variables}
\begin{verbatim}
...
k = 0 # this can be any integer that falls within the message space
...
\end{verbatim}
Unlike the Atbash Cipher, the Caesar cipher has a key. Here, it is limited to the alphabet used, e.g.:
\begin{itemize}
	\item in the single case English alphabet $\longrightarrow$ $k \in [0,25]$; or,
	\item for the extended ASCII alphabet $\longrightarrow$ $k \in [0,255]$.
\end{itemize}

\subsubsection{The encryption function}
\begin{verbatim}
def enc(z):
  for x in z:
    c_ord.append(x + k)
enc(m_ord)
\end{verbatim}

\subsubsection{The decryption function}
\begin{verbatim}
def dec(z):
  for x in z:
    m_ord_proof.append(x - k)
dec(c_ord)
\end{verbatim}

\subsection{Criticism of the Caesar cipher}
Looking at the similarity of the encryption and decryption algorithms for the Atbash and Caesar ciphers, it is patently clear that both ciphers suffer the same weakness---the keyspace is too small. Whilst the Caesar cipher grows the keyspace from 1 to either 26 or 256 (depending on the alphabet used), this is still within the realm of being crackable by brute-force without a computer.

Further, with a simple statistical analysis a user would be able to determine which letters replace common letters (e.g. the letter that appears most commonly is likely to substitute for ``e''). This is not a criticism unique to the Caesar cipher, it applies to any monoalphabetic substitution cipher (including non-linear substitutions), as well as many more sophisticated ciphers.

\section{The Vig\`enere cipher}
The Vig\`enere cipher was developed at least a thousand years after the aforementioned ciphers. It is, however, comparable, being a substitution cipher. Unlike the Atbash and Caesar ciphers, however, it is a polyaphabetic substitution cipher: in a polyalphabetic substitution cipher, the same input may return a different output (c.f. a monoalphabetic substitution cipher, where for each time a single letter is used in a message, the ciphertext will be the same).

It is essentially a cipher of addition: with the sum of the the numerical values of the message and the key making up the ciphertext. 

\begin{figure}[h!]
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\textit{message} & m & a & k & e & y & o & u & r & m & e & s & s & a & g & e & s & e & c & u & r & e \\ \hline
\textit{key} & s & w & e & e & t & s & w & e & e & t & s & w & e & e & t & s & w & e & e & t & s \\ \hline
\textit{ord(message)} & 77 & 65 & 75 & 69 & 89 & 79 & 85 & 82 & 77 & 69 & 83 & 83 & 65 & 71 & 69 & 83 & 69 & 67 & 85 & 82 & 69 \\ \hline
\textit{ord(key)} & 83 & 87 & 69 & 69 & 84 & 83 & 87 & 69 & 69 & 84 & 83 & 87 & 69 & 69 & 84 & 83 & 87 & 69 & 69 & 84 & 83\\ \hline
\textit{ord(ciphertext)} & 160 & 152 & 144 & 138 & 173 & 162 & 172 & 151 & 146 & 153 & 166 & 170 & 134 & 140 & 153 & 166 & 156 & 136 & 154 & 166 & 152\\ \hline
\end{tabular}
\caption{The Vig\`enere cipher for $k = ``sweet''$}
\end{figure}

\subsection{The Vig\`enere cipher in Python}

\subsubsection{Variables}

\begin{verbatim}
...
k_ord_long = [] # this holds a transformation of k S.T. len(m) = len(k_ord_long)
...
\end{verbatim}

\subsubsection{The encryption function}

\begin{verbatim}
def enc(z):
    for i,x in enumerate(m_ord):
        c_ord.append(m_ord[i] + k_ord_long[i])
enc(m_ord)
\end{verbatim}

\subsubsection{The decryption function}

\begin{verbatim}
def dec(z):
    for i,x in enumerate(c_ord):
        m_ord_proof.append(c_ord[i] - k_ord_long[i])
dec(c_ord_proof)
\end{verbatim}

\subsection{Criticism of the Vig\`enere cipher}
Where a Vig\`enere cipher has a small $k$, the cipher is susceptible to statistical distribution attacks. This becomes more difficult with the length of $k$. The strength of this cipher is not dependent on the strength of the encryption algorithm, but, rather the strength of the key---as such, it is not considered a ``strong'' cipher.

\section{One time pads}
The extreme example of the above comes in the form of a one time pad cipher. This is a strict subset of the Vig\`enere cipher, being a Vig\`enere cipher where $len(k) = len(m)$ and there is no discernible pattern in $k$ (e.g. $k$ is truly random). Where these requirements are satisfied and $k$ is not compromised, the cipher is not compromisable.

\section{Scytale cipher}
Unlike the above ciphers, the Scytale cipher is a transposition cipher (c.f. a substitution cipher). Substitution ciphers replace single letters with other letters. Transposition ciphers obscure meaning by reordering the message text to create the ciphertext. These were one of the earliest forms of ciphers used, and were reportedly used by the Ancient Greeks, including, notably, the Spartan army.

\begin{figure}[h!]
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\textit{message} & m & a & k & e & y & o & u & r & m & e & s & s & a & g & e & s & e & c & u & r & e \\ \hline
\textit{key line 1} & m & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & y & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & m & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & a & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & e & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & e \\ \hline
\textit{key line 2} & $\hookrightarrow$ & a & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & o & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & e & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & g & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & c & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ \\ \hline
\textit{key line 3} & $\rightarrow$& $\rightarrow$ & k & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & u & $\rightarrow$ & & $\rightarrow$ & s & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & e & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & u & $\rightarrow$ & $\rightarrow$ \\ \hline
\textit{key line 4} & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & e & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & r & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & s & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & s & $\rightarrow$ & $\rightarrow$ & $\rightarrow$ & r & $\bullet$\\ \hline
\textit{ciphertext} & m & y & m & a & e & e & a & o & e & g & c & k & u & s & e & u & e & r & s & s & r \\ \hline
\end{tabular}
\caption{The Vig\`enere cipher for $k = ``sweet''$}
\end{figure}

The word ``Scytale'' comes from the Greek word for ``baton'', which were one of the earliest tools used to encrypt and decrypt Scytale ciphers.

\subsection{The Scytale cipher in python}

\subsubsection{Variables}

\begin{verbatim}
...
order = [] # this holds  the order that the message will be arranged into to make ciphertext
...
\end{verbatim}

\subsubsection{The encryption function}

\begin{verbatim}
repetitions = int((len(m) / k)) + 1
for i in range(0,k):
    for j in range(0,repetitions):
        index = (i + (j * k))
        if index > len(m) - 1:
            continue
        else:
            order.append(index)
c = [m[i] for i in order]
\end{verbatim}

\section{Conclusion}
Although a conclusion may review the main points of the paper, it must not replicate the abstract. A conclusion might elaborate on the importance of the work or suggest applications and extensions. Do not cite references in the conclusion. Note that the conclusion section is the last section of the paper to be numbered. The appendix (if present), acknowledgment, and references are listed without numbers.

An Acknowledgments section, if used, immediately precedes the References. Sponsorship and financial support acknowledgments should be included here.

\section*{References}

\begin{thebibliography}{}
\bibitem{1} Vatistas, G. H., Lin, S., and Kwok, C. K., ``Reverse Flow Radius in Vortex Chambers,'' \textit{AIAA Journal}, Vol. 24, No. 11, 1986, pp. 1872, 1873. doi: 10.2514/3.13046

\end{thebibliography}
\end{document}
